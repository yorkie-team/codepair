/* tslint:disable */
/* eslint-disable */
/**
 * CodePair
 * The CodePair API description
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration";
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from "axios";
import globalAxios from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
	DUMMY_BASE_URL,
	assertParamExists,
	setApiKeyToObject,
	setBasicAuthToObject,
	setBearerAuthToObject,
	setOAuthToObject,
	setSearchParams,
	serializeDataIfNeeded,
	toPathString,
	createRequestFunction,
} from "./common";
import type { RequestArgs } from "./base";
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from "./base";

/**
 *
 * @export
 * @interface ChangeNicknameRequest
 */
export interface ChangeNicknameRequest {
	/**
	 * New nickname to update
	 * @type {string}
	 * @memberof ChangeNicknameRequest
	 */
	nickname: string;
}
/**
 *
 * @export
 * @interface CheckNameConflictRequest
 */
export interface CheckNameConflictRequest {
	/**
	 * Name to check for conflict
	 * @type {string}
	 * @memberof CheckNameConflictRequest
	 */
	name: string;
}
/**
 *
 * @export
 * @interface CheckNameConflictResponse
 */
export interface CheckNameConflictResponse {
	/**
	 * Indicates if the name is already in use
	 * @type {boolean}
	 * @memberof CheckNameConflictResponse
	 */
	conflict: boolean;
}
/**
 *
 * @export
 * @interface CheckYorkieRequest
 */
export interface CheckYorkieRequest {
	/**
	 * Authorization token provided by the client
	 * @type {string}
	 * @memberof CheckYorkieRequest
	 */
	token: string;
	/**
	 * Yorkie method to be invoked
	 * @type {string}
	 * @memberof CheckYorkieRequest
	 */
	method: CheckYorkieRequestMethodEnum;
	/**
	 * Additional attributes for authorization
	 * @type {Array<string>}
	 * @memberof CheckYorkieRequest
	 */
	attributes: Array<string>;
}

export const CheckYorkieRequestMethodEnum = {
	ActivateClient: "ActivateClient",
	DeactivateClient: "DeactivateClient",
	AttachDocument: "AttachDocument",
	DetachDocument: "DetachDocument",
	WatchDocuments: "WatchDocuments",
	PushPull: "PushPull",
} as const;

export type CheckYorkieRequestMethodEnum =
	(typeof CheckYorkieRequestMethodEnum)[keyof typeof CheckYorkieRequestMethodEnum];

/**
 *
 * @export
 * @interface CheckYorkieResponse
 */
export interface CheckYorkieResponse {
	/**
	 * Whether the token is authorized for the specified method
	 * @type {boolean}
	 * @memberof CheckYorkieResponse
	 */
	allowed: boolean;
	/**
	 * Reason or message explaining the authorization outcome
	 * @type {string}
	 * @memberof CheckYorkieResponse
	 */
	reason: string;
}
/**
 *
 * @export
 * @interface CreateInvitationTokenRequest
 */
export interface CreateInvitationTokenRequest {
	/**
	 * Expiration timestamp for the invitation token
	 * @type {string}
	 * @memberof CreateInvitationTokenRequest
	 */
	expiredAt: string;
}
/**
 *
 * @export
 * @interface CreateInvitationTokenResponse
 */
export interface CreateInvitationTokenResponse {
	/**
	 * Generated token for invitation
	 * @type {string}
	 * @memberof CreateInvitationTokenResponse
	 */
	invitationToken: string;
}
/**
 *
 * @export
 * @interface CreateUploadPresignedUrlRequest
 */
export interface CreateUploadPresignedUrlRequest {
	/**
	 * Workspace ID where the file will be stored
	 * @type {string}
	 * @memberof CreateUploadPresignedUrlRequest
	 */
	workspaceId: string;
	/**
	 * Size of the content to upload
	 * @type {number}
	 * @memberof CreateUploadPresignedUrlRequest
	 */
	contentLength: number;
	/**
	 * MIME type of the file to be uploaded
	 * @type {string}
	 * @memberof CreateUploadPresignedUrlRequest
	 */
	contentType: string;
}
/**
 *
 * @export
 * @interface CreateUploadPresignedUrlResponse
 */
export interface CreateUploadPresignedUrlResponse {
	/**
	 * Presigned URL for uploading the file
	 * @type {string}
	 * @memberof CreateUploadPresignedUrlResponse
	 */
	url: string;
	/**
	 * Storage key of the uploaded file
	 * @type {string}
	 * @memberof CreateUploadPresignedUrlResponse
	 */
	fileKey: string;
}
/**
 *
 * @export
 * @interface CreateWorkspaceDocumentRequest
 */
export interface CreateWorkspaceDocumentRequest {
	/**
	 * Title for the new document
	 * @type {string}
	 * @memberof CreateWorkspaceDocumentRequest
	 */
	title: string;
}
/**
 *
 * @export
 * @interface CreateWorkspaceDocumentShareTokenRequest
 */
export interface CreateWorkspaceDocumentShareTokenRequest {
	/**
	 * Share role for the document
	 * @type {string}
	 * @memberof CreateWorkspaceDocumentShareTokenRequest
	 */
	role: CreateWorkspaceDocumentShareTokenRequestRoleEnum;
	/**
	 * Expiration timestamp for the share link
	 * @type {string}
	 * @memberof CreateWorkspaceDocumentShareTokenRequest
	 */
	expiredAt: string;
}

export const CreateWorkspaceDocumentShareTokenRequestRoleEnum = {
	Read: "READ",
	Edit: "EDIT",
} as const;

export type CreateWorkspaceDocumentShareTokenRequestRoleEnum =
	(typeof CreateWorkspaceDocumentShareTokenRequestRoleEnum)[keyof typeof CreateWorkspaceDocumentShareTokenRequestRoleEnum];

/**
 *
 * @export
 * @interface CreateWorkspaceDocumentShareTokenResponse
 */
export interface CreateWorkspaceDocumentShareTokenResponse {
	/**
	 * Token used to share the document
	 * @type {string}
	 * @memberof CreateWorkspaceDocumentShareTokenResponse
	 */
	sharingToken: string;
}
/**
 *
 * @export
 * @interface CreateWorkspaceRequest
 */
export interface CreateWorkspaceRequest {
	/**
	 * Title for the new workspace
	 * @type {string}
	 * @memberof CreateWorkspaceRequest
	 */
	title: string;
}
/**
 *
 * @export
 * @interface ExportFileRequest
 */
export interface ExportFileRequest {
	/**
	 * Target format for export (e.g., PDF, HTML)
	 * @type {string}
	 * @memberof ExportFileRequest
	 */
	exportType: string;
	/**
	 * Markdown content to be exported
	 * @type {string}
	 * @memberof ExportFileRequest
	 */
	content: string;
	/**
	 * Desired filename (without extension)
	 * @type {string}
	 * @memberof ExportFileRequest
	 */
	fileName: string;
}
/**
 *
 * @export
 * @interface ExportFileResponse
 */
export interface ExportFileResponse {
	/**
	 * Binary content of the exported file
	 * @type {object}
	 * @memberof ExportFileResponse
	 */
	fileContent: object;
	/**
	 * MIME type of the exported file
	 * @type {string}
	 * @memberof ExportFileResponse
	 */
	mimeType: string;
	/**
	 * Name of the exported file (with extension)
	 * @type {string}
	 * @memberof ExportFileResponse
	 */
	fileName: string;
}
/**
 *
 * @export
 * @interface FileUploadConfig
 */
export interface FileUploadConfig {
	/**
	 * Whether file upload is enabled
	 * @type {boolean}
	 * @memberof FileUploadConfig
	 */
	enable: boolean;
}
/**
 *
 * @export
 * @interface FindDocumentFromSharingTokenResponse
 */
export interface FindDocumentFromSharingTokenResponse {
	/**
	 * Document ID
	 * @type {string}
	 * @memberof FindDocumentFromSharingTokenResponse
	 */
	id: string;
	/**
	 * Yorkie Document ID associated with the document
	 * @type {string}
	 * @memberof FindDocumentFromSharingTokenResponse
	 */
	yorkieDocumentId: string;
	/**
	 * Document title
	 * @type {string}
	 * @memberof FindDocumentFromSharingTokenResponse
	 */
	title: string;
	/**
	 * Document content
	 * @type {string}
	 * @memberof FindDocumentFromSharingTokenResponse
	 */
	content?: string;
	/**
	 * Timestamp of document creation
	 * @type {string}
	 * @memberof FindDocumentFromSharingTokenResponse
	 */
	createdAt: string;
	/**
	 * Timestamp of last document update
	 * @type {string}
	 * @memberof FindDocumentFromSharingTokenResponse
	 */
	updatedAt: string;
	/**
	 * ID of the workspace containing this document
	 * @type {string}
	 * @memberof FindDocumentFromSharingTokenResponse
	 */
	workspaceId: string;
	/**
	 * Share role from the token
	 * @type {string}
	 * @memberof FindDocumentFromSharingTokenResponse
	 */
	role: FindDocumentFromSharingTokenResponseRoleEnum;
}

export const FindDocumentFromSharingTokenResponseRoleEnum = {
	Read: "READ",
	Edit: "EDIT",
} as const;

export type FindDocumentFromSharingTokenResponseRoleEnum =
	(typeof FindDocumentFromSharingTokenResponseRoleEnum)[keyof typeof FindDocumentFromSharingTokenResponseRoleEnum];

/**
 *
 * @export
 * @interface FindSettingsResponse
 */
export interface FindSettingsResponse {
	/**
	 * Settings related to Yorkie Intelligence
	 * @type {YorkieIntelligenceConfig}
	 * @memberof FindSettingsResponse
	 */
	yorkieIntelligence: YorkieIntelligenceConfig;
	/**
	 * Settings related to file uploads
	 * @type {FileUploadConfig}
	 * @memberof FindSettingsResponse
	 */
	fileUpload: FileUploadConfig;
}
/**
 *
 * @export
 * @interface FindUserResponse
 */
export interface FindUserResponse {
	/**
	 * User ID
	 * @type {string}
	 * @memberof FindUserResponse
	 */
	id: string;
	/**
	 * User nickname
	 * @type {string}
	 * @memberof FindUserResponse
	 */
	nickname?: string;
	/**
	 * Last accessed workspace slug
	 * @type {string}
	 * @memberof FindUserResponse
	 */
	lastWorkspaceSlug?: string;
	/**
	 * Timestamp of user creation
	 * @type {string}
	 * @memberof FindUserResponse
	 */
	createdAt: string;
	/**
	 * Timestamp of last user update
	 * @type {string}
	 * @memberof FindUserResponse
	 */
	updatedAt: string;
}
/**
 *
 * @export
 * @interface FindWorkspaceDocumentsResponse
 */
export interface FindWorkspaceDocumentsResponse {
	/**
	 * List of retrieved workspace documents
	 * @type {Array<WorkspaceDocumentDomain>}
	 * @memberof FindWorkspaceDocumentsResponse
	 */
	documents: Array<WorkspaceDocumentDomain>;
	/**
	 * The ID of the last document (for pagination)
	 * @type {string}
	 * @memberof FindWorkspaceDocumentsResponse
	 */
	cursor: string;
	/**
	 * Total count of documents in the workspace
	 * @type {number}
	 * @memberof FindWorkspaceDocumentsResponse
	 */
	totalLength: number;
}
/**
 *
 * @export
 * @interface FindWorkspaceUsersResponse
 */
export interface FindWorkspaceUsersResponse {
	/**
	 * List of workspace users
	 * @type {Array<WorkspaceUserDomain>}
	 * @memberof FindWorkspaceUsersResponse
	 */
	workspaceUsers: Array<WorkspaceUserDomain>;
	/**
	 * The ID of the last workspace user (for pagination)
	 * @type {string}
	 * @memberof FindWorkspaceUsersResponse
	 */
	cursor: string;
	/**
	 * Total count of workspace users
	 * @type {number}
	 * @memberof FindWorkspaceUsersResponse
	 */
	totalLength: number;
}
/**
 *
 * @export
 * @interface FindWorkspacesResponse
 */
export interface FindWorkspacesResponse {
	/**
	 * List of retrieved workspaces
	 * @type {Array<WorkspaceDomain>}
	 * @memberof FindWorkspacesResponse
	 */
	workspaces: Array<WorkspaceDomain>;
	/**
	 * The ID of the last workspace (for pagination)
	 * @type {string}
	 * @memberof FindWorkspacesResponse
	 */
	cursor: string;
}
/**
 *
 * @export
 * @interface HelloRequest
 */
export interface HelloRequest {
	/**
	 * New nickname to say hello
	 * @type {string}
	 * @memberof HelloRequest
	 */
	nickname: string;
}
/**
 *
 * @export
 * @interface HelloResponse
 */
export interface HelloResponse {
	/**
	 * Welcome message
	 * @type {string}
	 * @memberof HelloResponse
	 */
	message: string;
}
/**
 *
 * @export
 * @interface HttpExceptionResponse
 */
export interface HttpExceptionResponse {
	/**
	 * HTTP status code
	 * @type {number}
	 * @memberof HttpExceptionResponse
	 */
	statusCode: HttpExceptionResponseStatusCodeEnum;
	/**
	 * Description of the error
	 * @type {string}
	 * @memberof HttpExceptionResponse
	 */
	message: string;
}

export const HttpExceptionResponseStatusCodeEnum = {
	NUMBER_100: 100,
	NUMBER_101: 101,
	NUMBER_102: 102,
	NUMBER_103: 103,
	NUMBER_200: 200,
	NUMBER_201: 201,
	NUMBER_202: 202,
	NUMBER_203: 203,
	NUMBER_204: 204,
	NUMBER_205: 205,
	NUMBER_206: 206,
	NUMBER_300: 300,
	NUMBER_301: 301,
	NUMBER_302: 302,
	NUMBER_303: 303,
	NUMBER_304: 304,
	NUMBER_307: 307,
	NUMBER_308: 308,
	NUMBER_400: 400,
	NUMBER_401: 401,
	NUMBER_402: 402,
	NUMBER_403: 403,
	NUMBER_404: 404,
	NUMBER_405: 405,
	NUMBER_406: 406,
	NUMBER_407: 407,
	NUMBER_408: 408,
	NUMBER_409: 409,
	NUMBER_410: 410,
	NUMBER_411: 411,
	NUMBER_412: 412,
	NUMBER_413: 413,
	NUMBER_414: 414,
	NUMBER_415: 415,
	NUMBER_416: 416,
	NUMBER_417: 417,
	NUMBER_418: 418,
	NUMBER_421: 421,
	NUMBER_422: 422,
	NUMBER_424: 424,
	NUMBER_428: 428,
	NUMBER_429: 429,
	NUMBER_500: 500,
	NUMBER_501: 501,
	NUMBER_502: 502,
	NUMBER_503: 503,
	NUMBER_504: 504,
	NUMBER_505: 505,
} as const;

export type HttpExceptionResponseStatusCodeEnum =
	(typeof HttpExceptionResponseStatusCodeEnum)[keyof typeof HttpExceptionResponseStatusCodeEnum];

/**
 *
 * @export
 * @interface JoinWorkspaceRequest
 */
export interface JoinWorkspaceRequest {
	/**
	 * Valid invitation token to join the workspace
	 * @type {string}
	 * @memberof JoinWorkspaceRequest
	 */
	invitationToken: string;
}
/**
 *
 * @export
 * @interface RefreshTokenRequest
 */
export interface RefreshTokenRequest {
	/**
	 * Refresh token for requesting a new access token
	 * @type {string}
	 * @memberof RefreshTokenRequest
	 */
	refreshToken: string;
}
/**
 *
 * @export
 * @interface RefreshTokenResponse
 */
export interface RefreshTokenResponse {
	/**
	 * The newly issued access token
	 * @type {string}
	 * @memberof RefreshTokenResponse
	 */
	newAccessToken: string;
}
/**
 *
 * @export
 * @interface RunFeatureRequest
 */
export interface RunFeatureRequest {
	/**
	 * Document ID on which the feature will be applied
	 * @type {string}
	 * @memberof RunFeatureRequest
	 */
	documentId: string;
	/**
	 * Content or query for the intelligence feature
	 * @type {string}
	 * @memberof RunFeatureRequest
	 */
	content: string;
}
/**
 *
 * @export
 * @interface RunFollowUpRequest
 */
export interface RunFollowUpRequest {
	/**
	 * Document ID to apply the follow-up
	 * @type {string}
	 * @memberof RunFollowUpRequest
	 */
	documentId: string;
	/**
	 * Key representing the relevant chat history
	 * @type {string}
	 * @memberof RunFollowUpRequest
	 */
	memoryKey: string;
	/**
	 * Content or query to run the follow-up feature on
	 * @type {string}
	 * @memberof RunFollowUpRequest
	 */
	content: string;
}
/**
 *
 * @export
 * @interface UpdateDocumentTitleRequest
 */
export interface UpdateDocumentTitleRequest {
	/**
	 * New title for the document
	 * @type {string}
	 * @memberof UpdateDocumentTitleRequest
	 */
	title: string;
}
/**
 *
 * @export
 * @interface WorkspaceDocumentDomain
 */
export interface WorkspaceDocumentDomain {
	/**
	 * Document ID
	 * @type {string}
	 * @memberof WorkspaceDocumentDomain
	 */
	id: string;
	/**
	 * Yorkie Document ID associated with the document
	 * @type {string}
	 * @memberof WorkspaceDocumentDomain
	 */
	yorkieDocumentId: string;
	/**
	 * Document title
	 * @type {string}
	 * @memberof WorkspaceDocumentDomain
	 */
	title: string;
	/**
	 * Document content
	 * @type {string}
	 * @memberof WorkspaceDocumentDomain
	 */
	content?: string;
	/**
	 * Timestamp of document creation
	 * @type {string}
	 * @memberof WorkspaceDocumentDomain
	 */
	createdAt: string;
	/**
	 * Timestamp of last document update
	 * @type {string}
	 * @memberof WorkspaceDocumentDomain
	 */
	updatedAt: string;
	/**
	 * ID of the workspace containing this document
	 * @type {string}
	 * @memberof WorkspaceDocumentDomain
	 */
	workspaceId: string;
}
/**
 *
 * @export
 * @interface WorkspaceDomain
 */
export interface WorkspaceDomain {
	/**
	 * Workspace ID
	 * @type {string}
	 * @memberof WorkspaceDomain
	 */
	id: string;
	/**
	 * Title of the workspace
	 * @type {string}
	 * @memberof WorkspaceDomain
	 */
	title: string;
	/**
	 * Slug of the workspace
	 * @type {string}
	 * @memberof WorkspaceDomain
	 */
	slug: string;
	/**
	 * Timestamp of workspace creation
	 * @type {string}
	 * @memberof WorkspaceDomain
	 */
	createdAt: string;
	/**
	 * Timestamp of last workspace update
	 * @type {string}
	 * @memberof WorkspaceDomain
	 */
	updatedAt: string;
}
/**
 *
 * @export
 * @interface WorkspaceUserDomain
 */
export interface WorkspaceUserDomain {
	/**
	 * User ID
	 * @type {string}
	 * @memberof WorkspaceUserDomain
	 */
	id: string;
	/**
	 * User nickname
	 * @type {string}
	 * @memberof WorkspaceUserDomain
	 */
	nickname: string;
	/**
	 * Timestamp of user creation
	 * @type {string}
	 * @memberof WorkspaceUserDomain
	 */
	createdAt: string;
	/**
	 * Timestamp of last user update
	 * @type {string}
	 * @memberof WorkspaceUserDomain
	 */
	updatedAt: string;
}
/**
 *
 * @export
 * @interface YorkieIntelligenceConfig
 */
export interface YorkieIntelligenceConfig {
	/**
	 * Whether Yorkie Intelligence features are enabled
	 * @type {boolean}
	 * @memberof YorkieIntelligenceConfig
	 */
	enable: boolean;
	/**
	 * Additional Yorkie Intelligence configuration
	 * @type {object}
	 * @memberof YorkieIntelligenceConfig
	 */
	config: object;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * Redirects the user to GitHub OAuth login. On successful login, redirects the user back to the frontend with accessToken and refreshToken in the URL query parameters.
		 * @summary Log In or Sign Up via GitHub
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		loginWithGithub: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
			const localVarPath = `/auth/login/github`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Generates a new access token using the provided refresh token.
		 * @summary Refresh Access Token
		 * @param {RefreshTokenRequest} refreshTokenRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		refreshAccessToken: async (
			refreshTokenRequest: RefreshTokenRequest,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'refreshTokenRequest' is not null or undefined
			assertParamExists("refreshAccessToken", "refreshTokenRequest", refreshTokenRequest);
			const localVarPath = `/auth/refresh`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				refreshTokenRequest,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration);
	return {
		/**
		 * Redirects the user to GitHub OAuth login. On successful login, redirects the user back to the frontend with accessToken and refreshToken in the URL query parameters.
		 * @summary Log In or Sign Up via GitHub
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async loginWithGithub(
			options?: RawAxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.loginWithGithub(options);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["AuthApi.loginWithGithub"]?.[localVarOperationServerIndex]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * Generates a new access token using the provided refresh token.
		 * @summary Refresh Access Token
		 * @param {RefreshTokenRequest} refreshTokenRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async refreshAccessToken(
			refreshTokenRequest: RefreshTokenRequest,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshTokenResponse>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.refreshAccessToken(
				refreshTokenRequest,
				options
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["AuthApi.refreshAccessToken"]?.[localVarOperationServerIndex]
					?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
	};
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = AuthApiFp(configuration);
	return {
		/**
		 * Redirects the user to GitHub OAuth login. On successful login, redirects the user back to the frontend with accessToken and refreshToken in the URL query parameters.
		 * @summary Log In or Sign Up via GitHub
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		loginWithGithub(options?: RawAxiosRequestConfig): AxiosPromise<void> {
			return localVarFp.loginWithGithub(options).then((request) => request(axios, basePath));
		},
		/**
		 * Generates a new access token using the provided refresh token.
		 * @summary Refresh Access Token
		 * @param {RefreshTokenRequest} refreshTokenRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		refreshAccessToken(
			refreshTokenRequest: RefreshTokenRequest,
			options?: RawAxiosRequestConfig
		): AxiosPromise<RefreshTokenResponse> {
			return localVarFp
				.refreshAccessToken(refreshTokenRequest, options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
	/**
	 * Redirects the user to GitHub OAuth login. On successful login, redirects the user back to the frontend with accessToken and refreshToken in the URL query parameters.
	 * @summary Log In or Sign Up via GitHub
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AuthApi
	 */
	public loginWithGithub(options?: RawAxiosRequestConfig) {
		return AuthApiFp(this.configuration)
			.loginWithGithub(options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Generates a new access token using the provided refresh token.
	 * @summary Refresh Access Token
	 * @param {RefreshTokenRequest} refreshTokenRequest
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AuthApi
	 */
	public refreshAccessToken(
		refreshTokenRequest: RefreshTokenRequest,
		options?: RawAxiosRequestConfig
	) {
		return AuthApiFp(this.configuration)
			.refreshAccessToken(refreshTokenRequest, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * CheckApi - axios parameter creator
 * @export
 */
export const CheckApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * Checks if a given name conflicts with any username or workspace title.
		 * @summary Check Name Conflict
		 * @param {CheckNameConflictRequest} checkNameConflictRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		checkNameConflict: async (
			checkNameConflictRequest: CheckNameConflictRequest,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'checkNameConflictRequest' is not null or undefined
			assertParamExists(
				"checkNameConflict",
				"checkNameConflictRequest",
				checkNameConflictRequest
			);
			const localVarPath = `/check/name-conflict`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				checkNameConflictRequest,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Checks if the user is authorized to perform a given Yorkie operation.
		 * @summary Check Yorkie Authorization
		 * @param {CheckYorkieRequest} checkYorkieRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		checkYorkie: async (
			checkYorkieRequest: CheckYorkieRequest,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'checkYorkieRequest' is not null or undefined
			assertParamExists("checkYorkie", "checkYorkieRequest", checkYorkieRequest);
			const localVarPath = `/check/yorkie`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				checkYorkieRequest,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * CheckApi - functional programming interface
 * @export
 */
export const CheckApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = CheckApiAxiosParamCreator(configuration);
	return {
		/**
		 * Checks if a given name conflicts with any username or workspace title.
		 * @summary Check Name Conflict
		 * @param {CheckNameConflictRequest} checkNameConflictRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async checkNameConflict(
			checkNameConflictRequest: CheckNameConflictRequest,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckNameConflictResponse>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.checkNameConflict(
				checkNameConflictRequest,
				options
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["CheckApi.checkNameConflict"]?.[localVarOperationServerIndex]
					?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * Checks if the user is authorized to perform a given Yorkie operation.
		 * @summary Check Yorkie Authorization
		 * @param {CheckYorkieRequest} checkYorkieRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async checkYorkie(
			checkYorkieRequest: CheckYorkieRequest,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckYorkieResponse>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.checkYorkie(
				checkYorkieRequest,
				options
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["CheckApi.checkYorkie"]?.[localVarOperationServerIndex]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
	};
};

/**
 * CheckApi - factory interface
 * @export
 */
export const CheckApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = CheckApiFp(configuration);
	return {
		/**
		 * Checks if a given name conflicts with any username or workspace title.
		 * @summary Check Name Conflict
		 * @param {CheckNameConflictRequest} checkNameConflictRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		checkNameConflict(
			checkNameConflictRequest: CheckNameConflictRequest,
			options?: RawAxiosRequestConfig
		): AxiosPromise<CheckNameConflictResponse> {
			return localVarFp
				.checkNameConflict(checkNameConflictRequest, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Checks if the user is authorized to perform a given Yorkie operation.
		 * @summary Check Yorkie Authorization
		 * @param {CheckYorkieRequest} checkYorkieRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		checkYorkie(
			checkYorkieRequest: CheckYorkieRequest,
			options?: RawAxiosRequestConfig
		): AxiosPromise<CheckYorkieResponse> {
			return localVarFp
				.checkYorkie(checkYorkieRequest, options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * CheckApi - object-oriented interface
 * @export
 * @class CheckApi
 * @extends {BaseAPI}
 */
export class CheckApi extends BaseAPI {
	/**
	 * Checks if a given name conflicts with any username or workspace title.
	 * @summary Check Name Conflict
	 * @param {CheckNameConflictRequest} checkNameConflictRequest
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CheckApi
	 */
	public checkNameConflict(
		checkNameConflictRequest: CheckNameConflictRequest,
		options?: RawAxiosRequestConfig
	) {
		return CheckApiFp(this.configuration)
			.checkNameConflict(checkNameConflictRequest, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Checks if the user is authorized to perform a given Yorkie operation.
	 * @summary Check Yorkie Authorization
	 * @param {CheckYorkieRequest} checkYorkieRequest
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CheckApi
	 */
	public checkYorkie(checkYorkieRequest: CheckYorkieRequest, options?: RawAxiosRequestConfig) {
		return CheckApiFp(this.configuration)
			.checkYorkie(checkYorkieRequest, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * DocumentsApi - axios parameter creator
 * @export
 */
export const DocumentsApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * Returns a shared document if the sharing token is valid and the user has access.
		 * @summary Retrieve Document by Sharing Token
		 * @param {string} token Valid sharing token to retrieve the document.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		findDocumentFromSharingToken: async (
			token: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'token' is not null or undefined
			assertParamExists("findDocumentFromSharingToken", "token", token);
			const localVarPath = `/documents/share`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (token !== undefined) {
				localVarQueryParameter["token"] = token;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * DocumentsApi - functional programming interface
 * @export
 */
export const DocumentsApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = DocumentsApiAxiosParamCreator(configuration);
	return {
		/**
		 * Returns a shared document if the sharing token is valid and the user has access.
		 * @summary Retrieve Document by Sharing Token
		 * @param {string} token Valid sharing token to retrieve the document.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async findDocumentFromSharingToken(
			token: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<FindDocumentFromSharingTokenResponse>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.findDocumentFromSharingToken(
				token,
				options
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DocumentsApi.findDocumentFromSharingToken"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
	};
};

/**
 * DocumentsApi - factory interface
 * @export
 */
export const DocumentsApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = DocumentsApiFp(configuration);
	return {
		/**
		 * Returns a shared document if the sharing token is valid and the user has access.
		 * @summary Retrieve Document by Sharing Token
		 * @param {string} token Valid sharing token to retrieve the document.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		findDocumentFromSharingToken(
			token: string,
			options?: RawAxiosRequestConfig
		): AxiosPromise<FindDocumentFromSharingTokenResponse> {
			return localVarFp
				.findDocumentFromSharingToken(token, options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * DocumentsApi - object-oriented interface
 * @export
 * @class DocumentsApi
 * @extends {BaseAPI}
 */
export class DocumentsApi extends BaseAPI {
	/**
	 * Returns a shared document if the sharing token is valid and the user has access.
	 * @summary Retrieve Document by Sharing Token
	 * @param {string} token Valid sharing token to retrieve the document.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DocumentsApi
	 */
	public findDocumentFromSharingToken(token: string, options?: RawAxiosRequestConfig) {
		return DocumentsApiFp(this.configuration)
			.findDocumentFromSharingToken(token, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * Generates a presigned URL for file download.
		 * @summary Create Presigned URL (Download)
		 * @param {string} fileName
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createDownloadPresignedUrl: async (
			fileName: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'fileName' is not null or undefined
			assertParamExists("createDownloadPresignedUrl", "fileName", fileName);
			const localVarPath = `/files/{file_name}`.replace(
				`{${"file_name"}}`,
				encodeURIComponent(String(fileName))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Generates a presigned URL for file upload.
		 * @summary Create Presigned URL (Upload)
		 * @param {CreateUploadPresignedUrlRequest} createUploadPresignedUrlRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createUploadPresignedUrl: async (
			createUploadPresignedUrlRequest: CreateUploadPresignedUrlRequest,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'createUploadPresignedUrlRequest' is not null or undefined
			assertParamExists(
				"createUploadPresignedUrl",
				"createUploadPresignedUrlRequest",
				createUploadPresignedUrlRequest
			);
			const localVarPath = `/files`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				createUploadPresignedUrlRequest,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Exports the given Markdown content to various file formats.
		 * @summary Export Markdown
		 * @param {ExportFileRequest} exportFileRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		exportMarkdown: async (
			exportFileRequest: ExportFileRequest,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'exportFileRequest' is not null or undefined
			assertParamExists("exportMarkdown", "exportFileRequest", exportFileRequest);
			const localVarPath = `/files/export-markdown`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				exportFileRequest,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration);
	return {
		/**
		 * Generates a presigned URL for file download.
		 * @summary Create Presigned URL (Download)
		 * @param {string} fileName
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async createDownloadPresignedUrl(
			fileName: string,
			options?: RawAxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.createDownloadPresignedUrl(
				fileName,
				options
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["FilesApi.createDownloadPresignedUrl"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * Generates a presigned URL for file upload.
		 * @summary Create Presigned URL (Upload)
		 * @param {CreateUploadPresignedUrlRequest} createUploadPresignedUrlRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async createUploadPresignedUrl(
			createUploadPresignedUrlRequest: CreateUploadPresignedUrlRequest,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<CreateUploadPresignedUrlResponse>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.createUploadPresignedUrl(
				createUploadPresignedUrlRequest,
				options
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["FilesApi.createUploadPresignedUrl"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * Exports the given Markdown content to various file formats.
		 * @summary Export Markdown
		 * @param {ExportFileRequest} exportFileRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async exportMarkdown(
			exportFileRequest: ExportFileRequest,
			options?: RawAxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportFileResponse>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.exportMarkdown(
				exportFileRequest,
				options
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["FilesApi.exportMarkdown"]?.[localVarOperationServerIndex]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
	};
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = FilesApiFp(configuration);
	return {
		/**
		 * Generates a presigned URL for file download.
		 * @summary Create Presigned URL (Download)
		 * @param {string} fileName
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createDownloadPresignedUrl(
			fileName: string,
			options?: RawAxiosRequestConfig
		): AxiosPromise<void> {
			return localVarFp
				.createDownloadPresignedUrl(fileName, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Generates a presigned URL for file upload.
		 * @summary Create Presigned URL (Upload)
		 * @param {CreateUploadPresignedUrlRequest} createUploadPresignedUrlRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createUploadPresignedUrl(
			createUploadPresignedUrlRequest: CreateUploadPresignedUrlRequest,
			options?: RawAxiosRequestConfig
		): AxiosPromise<CreateUploadPresignedUrlResponse> {
			return localVarFp
				.createUploadPresignedUrl(createUploadPresignedUrlRequest, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Exports the given Markdown content to various file formats.
		 * @summary Export Markdown
		 * @param {ExportFileRequest} exportFileRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		exportMarkdown(
			exportFileRequest: ExportFileRequest,
			options?: RawAxiosRequestConfig
		): AxiosPromise<ExportFileResponse> {
			return localVarFp
				.exportMarkdown(exportFileRequest, options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
	/**
	 * Generates a presigned URL for file download.
	 * @summary Create Presigned URL (Download)
	 * @param {string} fileName
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof FilesApi
	 */
	public createDownloadPresignedUrl(fileName: string, options?: RawAxiosRequestConfig) {
		return FilesApiFp(this.configuration)
			.createDownloadPresignedUrl(fileName, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Generates a presigned URL for file upload.
	 * @summary Create Presigned URL (Upload)
	 * @param {CreateUploadPresignedUrlRequest} createUploadPresignedUrlRequest
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof FilesApi
	 */
	public createUploadPresignedUrl(
		createUploadPresignedUrlRequest: CreateUploadPresignedUrlRequest,
		options?: RawAxiosRequestConfig
	) {
		return FilesApiFp(this.configuration)
			.createUploadPresignedUrl(createUploadPresignedUrlRequest, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Exports the given Markdown content to various file formats.
	 * @summary Export Markdown
	 * @param {ExportFileRequest} exportFileRequest
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof FilesApi
	 */
	public exportMarkdown(exportFileRequest: ExportFileRequest, options?: RawAxiosRequestConfig) {
		return FilesApiFp(this.configuration)
			.exportMarkdown(exportFileRequest, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * HelloApi - axios parameter creator
 * @export
 */
export const HelloApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * Creates a new hello message for a visitor.
		 * @summary Create Hello Message
		 * @param {HelloRequest} helloRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createHello: async (
			helloRequest: HelloRequest,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'helloRequest' is not null or undefined
			assertParamExists("createHello", "helloRequest", helloRequest);
			const localVarPath = `/hello`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				helloRequest,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Deletes the hello message for the visitor with the given ID.
		 * @summary Delete Hello Message
		 * @param {string} id Unique identifier for the visitor
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteHello: async (
			id: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists("deleteHello", "id", id);
			const localVarPath = `/hello/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Retrieves a hello message for the visitor with the given ID.
		 * @summary Get Hello Message
		 * @param {string} id Unique identifier for the visitor
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readHello: async (
			id: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists("readHello", "id", id);
			const localVarPath = `/hello/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Updates the hello message for the visitor with the given ID.
		 * @summary Update Hello Message
		 * @param {string} id Unique identifier for the visitor
		 * @param {HelloRequest} helloRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateHello: async (
			id: string,
			helloRequest: HelloRequest,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists("updateHello", "id", id);
			// verify required parameter 'helloRequest' is not null or undefined
			assertParamExists("updateHello", "helloRequest", helloRequest);
			const localVarPath = `/hello/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				helloRequest,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * HelloApi - functional programming interface
 * @export
 */
export const HelloApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = HelloApiAxiosParamCreator(configuration);
	return {
		/**
		 * Creates a new hello message for a visitor.
		 * @summary Create Hello Message
		 * @param {HelloRequest} helloRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async createHello(
			helloRequest: HelloRequest,
			options?: RawAxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelloResponse>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.createHello(
				helloRequest,
				options
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["HelloApi.createHello"]?.[localVarOperationServerIndex]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * Deletes the hello message for the visitor with the given ID.
		 * @summary Delete Hello Message
		 * @param {string} id Unique identifier for the visitor
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async deleteHello(
			id: string,
			options?: RawAxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelloResponse>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.deleteHello(id, options);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["HelloApi.deleteHello"]?.[localVarOperationServerIndex]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * Retrieves a hello message for the visitor with the given ID.
		 * @summary Get Hello Message
		 * @param {string} id Unique identifier for the visitor
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async readHello(
			id: string,
			options?: RawAxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelloResponse>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.readHello(id, options);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["HelloApi.readHello"]?.[localVarOperationServerIndex]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * Updates the hello message for the visitor with the given ID.
		 * @summary Update Hello Message
		 * @param {string} id Unique identifier for the visitor
		 * @param {HelloRequest} helloRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async updateHello(
			id: string,
			helloRequest: HelloRequest,
			options?: RawAxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelloResponse>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.updateHello(
				id,
				helloRequest,
				options
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["HelloApi.updateHello"]?.[localVarOperationServerIndex]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
	};
};

/**
 * HelloApi - factory interface
 * @export
 */
export const HelloApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = HelloApiFp(configuration);
	return {
		/**
		 * Creates a new hello message for a visitor.
		 * @summary Create Hello Message
		 * @param {HelloRequest} helloRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createHello(
			helloRequest: HelloRequest,
			options?: RawAxiosRequestConfig
		): AxiosPromise<HelloResponse> {
			return localVarFp
				.createHello(helloRequest, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Deletes the hello message for the visitor with the given ID.
		 * @summary Delete Hello Message
		 * @param {string} id Unique identifier for the visitor
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteHello(id: string, options?: RawAxiosRequestConfig): AxiosPromise<HelloResponse> {
			return localVarFp.deleteHello(id, options).then((request) => request(axios, basePath));
		},
		/**
		 * Retrieves a hello message for the visitor with the given ID.
		 * @summary Get Hello Message
		 * @param {string} id Unique identifier for the visitor
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readHello(id: string, options?: RawAxiosRequestConfig): AxiosPromise<HelloResponse> {
			return localVarFp.readHello(id, options).then((request) => request(axios, basePath));
		},
		/**
		 * Updates the hello message for the visitor with the given ID.
		 * @summary Update Hello Message
		 * @param {string} id Unique identifier for the visitor
		 * @param {HelloRequest} helloRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateHello(
			id: string,
			helloRequest: HelloRequest,
			options?: RawAxiosRequestConfig
		): AxiosPromise<HelloResponse> {
			return localVarFp
				.updateHello(id, helloRequest, options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * HelloApi - object-oriented interface
 * @export
 * @class HelloApi
 * @extends {BaseAPI}
 */
export class HelloApi extends BaseAPI {
	/**
	 * Creates a new hello message for a visitor.
	 * @summary Create Hello Message
	 * @param {HelloRequest} helloRequest
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof HelloApi
	 */
	public createHello(helloRequest: HelloRequest, options?: RawAxiosRequestConfig) {
		return HelloApiFp(this.configuration)
			.createHello(helloRequest, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Deletes the hello message for the visitor with the given ID.
	 * @summary Delete Hello Message
	 * @param {string} id Unique identifier for the visitor
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof HelloApi
	 */
	public deleteHello(id: string, options?: RawAxiosRequestConfig) {
		return HelloApiFp(this.configuration)
			.deleteHello(id, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Retrieves a hello message for the visitor with the given ID.
	 * @summary Get Hello Message
	 * @param {string} id Unique identifier for the visitor
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof HelloApi
	 */
	public readHello(id: string, options?: RawAxiosRequestConfig) {
		return HelloApiFp(this.configuration)
			.readHello(id, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Updates the hello message for the visitor with the given ID.
	 * @summary Update Hello Message
	 * @param {string} id Unique identifier for the visitor
	 * @param {HelloRequest} helloRequest
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof HelloApi
	 */
	public updateHello(id: string, helloRequest: HelloRequest, options?: RawAxiosRequestConfig) {
		return HelloApiFp(this.configuration)
			.updateHello(id, helloRequest, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * IntelligencesApi - axios parameter creator
 * @export
 */
export const IntelligencesApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * Executes a follow-up request (Yorkie Intelligence) after a feature run.
		 * @summary Run Follow-Up Intelligence
		 * @param {RunFollowUpRequest} runFollowUpRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		runFollowUpIntelligence: async (
			runFollowUpRequest: RunFollowUpRequest,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'runFollowUpRequest' is not null or undefined
			assertParamExists("runFollowUpIntelligence", "runFollowUpRequest", runFollowUpRequest);
			const localVarPath = `/intelligence`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				runFollowUpRequest,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Executes the chosen Yorkie Intelligence feature.
		 * @summary Run Specific Intelligence Feature
		 * @param {RunIntelligenceFeatureFeatureEnum} feature The intelligence feature to run.
		 * @param {RunFeatureRequest} runFeatureRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		runIntelligenceFeature: async (
			feature: RunIntelligenceFeatureFeatureEnum,
			runFeatureRequest: RunFeatureRequest,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'feature' is not null or undefined
			assertParamExists("runIntelligenceFeature", "feature", feature);
			// verify required parameter 'runFeatureRequest' is not null or undefined
			assertParamExists("runIntelligenceFeature", "runFeatureRequest", runFeatureRequest);
			const localVarPath = `/intelligence/{feature}`.replace(
				`{${"feature"}}`,
				encodeURIComponent(String(feature))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				runFeatureRequest,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * IntelligencesApi - functional programming interface
 * @export
 */
export const IntelligencesApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = IntelligencesApiAxiosParamCreator(configuration);
	return {
		/**
		 * Executes a follow-up request (Yorkie Intelligence) after a feature run.
		 * @summary Run Follow-Up Intelligence
		 * @param {RunFollowUpRequest} runFollowUpRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async runFollowUpIntelligence(
			runFollowUpRequest: RunFollowUpRequest,
			options?: RawAxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.runFollowUpIntelligence(
				runFollowUpRequest,
				options
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["IntelligencesApi.runFollowUpIntelligence"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * Executes the chosen Yorkie Intelligence feature.
		 * @summary Run Specific Intelligence Feature
		 * @param {RunIntelligenceFeatureFeatureEnum} feature The intelligence feature to run.
		 * @param {RunFeatureRequest} runFeatureRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async runIntelligenceFeature(
			feature: RunIntelligenceFeatureFeatureEnum,
			runFeatureRequest: RunFeatureRequest,
			options?: RawAxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.runIntelligenceFeature(
				feature,
				runFeatureRequest,
				options
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["IntelligencesApi.runIntelligenceFeature"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
	};
};

/**
 * IntelligencesApi - factory interface
 * @export
 */
export const IntelligencesApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = IntelligencesApiFp(configuration);
	return {
		/**
		 * Executes a follow-up request (Yorkie Intelligence) after a feature run.
		 * @summary Run Follow-Up Intelligence
		 * @param {RunFollowUpRequest} runFollowUpRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		runFollowUpIntelligence(
			runFollowUpRequest: RunFollowUpRequest,
			options?: RawAxiosRequestConfig
		): AxiosPromise<string> {
			return localVarFp
				.runFollowUpIntelligence(runFollowUpRequest, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Executes the chosen Yorkie Intelligence feature.
		 * @summary Run Specific Intelligence Feature
		 * @param {RunIntelligenceFeatureFeatureEnum} feature The intelligence feature to run.
		 * @param {RunFeatureRequest} runFeatureRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		runIntelligenceFeature(
			feature: RunIntelligenceFeatureFeatureEnum,
			runFeatureRequest: RunFeatureRequest,
			options?: RawAxiosRequestConfig
		): AxiosPromise<string> {
			return localVarFp
				.runIntelligenceFeature(feature, runFeatureRequest, options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * IntelligencesApi - object-oriented interface
 * @export
 * @class IntelligencesApi
 * @extends {BaseAPI}
 */
export class IntelligencesApi extends BaseAPI {
	/**
	 * Executes a follow-up request (Yorkie Intelligence) after a feature run.
	 * @summary Run Follow-Up Intelligence
	 * @param {RunFollowUpRequest} runFollowUpRequest
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof IntelligencesApi
	 */
	public runFollowUpIntelligence(
		runFollowUpRequest: RunFollowUpRequest,
		options?: RawAxiosRequestConfig
	) {
		return IntelligencesApiFp(this.configuration)
			.runFollowUpIntelligence(runFollowUpRequest, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Executes the chosen Yorkie Intelligence feature.
	 * @summary Run Specific Intelligence Feature
	 * @param {RunIntelligenceFeatureFeatureEnum} feature The intelligence feature to run.
	 * @param {RunFeatureRequest} runFeatureRequest
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof IntelligencesApi
	 */
	public runIntelligenceFeature(
		feature: RunIntelligenceFeatureFeatureEnum,
		runFeatureRequest: RunFeatureRequest,
		options?: RawAxiosRequestConfig
	) {
		return IntelligencesApiFp(this.configuration)
			.runIntelligenceFeature(feature, runFeatureRequest, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * @export
 */
export const RunIntelligenceFeatureFeatureEnum = {
	GithubIssue: "github-issue",
	GithubPr: "github-pr",
	DocumentWriting: "document-writing",
	Summarize: "summarize",
} as const;
export type RunIntelligenceFeatureFeatureEnum =
	(typeof RunIntelligenceFeatureFeatureEnum)[keyof typeof RunIntelligenceFeatureFeatureEnum];

/**
 * SettingsApi - axios parameter creator
 * @export
 */
export const SettingsApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * Retrieves the application (CodePair) settings for the client.
		 * @summary Get Application Settings
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
			const localVarPath = `/settings`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * SettingsApi - functional programming interface
 * @export
 */
export const SettingsApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = SettingsApiAxiosParamCreator(configuration);
	return {
		/**
		 * Retrieves the application (CodePair) settings for the client.
		 * @summary Get Application Settings
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getSettings(
			options?: RawAxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getSettings(options);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["SettingsApi.getSettings"]?.[localVarOperationServerIndex]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
	};
};

/**
 * SettingsApi - factory interface
 * @export
 */
export const SettingsApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = SettingsApiFp(configuration);
	return {
		/**
		 * Retrieves the application (CodePair) settings for the client.
		 * @summary Get Application Settings
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getSettings(options?: RawAxiosRequestConfig): AxiosPromise<void> {
			return localVarFp.getSettings(options).then((request) => request(axios, basePath));
		},
	};
};

/**
 * SettingsApi - object-oriented interface
 * @export
 * @class SettingsApi
 * @extends {BaseAPI}
 */
export class SettingsApi extends BaseAPI {
	/**
	 * Retrieves the application (CodePair) settings for the client.
	 * @summary Get Application Settings
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SettingsApi
	 */
	public getSettings(options?: RawAxiosRequestConfig) {
		return SettingsApiFp(this.configuration)
			.getSettings(options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * Returns the authenticated user\'s information.
		 * @summary Retrieve Authenticated User
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		findOneUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
			const localVarPath = `/users`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Updates the nickname of the authenticated user.
		 * @summary Update User Nickname
		 * @param {ChangeNicknameRequest} changeNicknameRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateUserNickname: async (
			changeNicknameRequest: ChangeNicknameRequest,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'changeNicknameRequest' is not null or undefined
			assertParamExists("updateUserNickname", "changeNicknameRequest", changeNicknameRequest);
			const localVarPath = `/users`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				changeNicknameRequest,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration);
	return {
		/**
		 * Returns the authenticated user\'s information.
		 * @summary Retrieve Authenticated User
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async findOneUser(
			options?: RawAxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindUserResponse>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.findOneUser(options);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["UsersApi.findOneUser"]?.[localVarOperationServerIndex]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * Updates the nickname of the authenticated user.
		 * @summary Update User Nickname
		 * @param {ChangeNicknameRequest} changeNicknameRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async updateUserNickname(
			changeNicknameRequest: ChangeNicknameRequest,
			options?: RawAxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserNickname(
				changeNicknameRequest,
				options
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["UsersApi.updateUserNickname"]?.[localVarOperationServerIndex]
					?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
	};
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = UsersApiFp(configuration);
	return {
		/**
		 * Returns the authenticated user\'s information.
		 * @summary Retrieve Authenticated User
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		findOneUser(options?: RawAxiosRequestConfig): AxiosPromise<FindUserResponse> {
			return localVarFp.findOneUser(options).then((request) => request(axios, basePath));
		},
		/**
		 * Updates the nickname of the authenticated user.
		 * @summary Update User Nickname
		 * @param {ChangeNicknameRequest} changeNicknameRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateUserNickname(
			changeNicknameRequest: ChangeNicknameRequest,
			options?: RawAxiosRequestConfig
		): AxiosPromise<void> {
			return localVarFp
				.updateUserNickname(changeNicknameRequest, options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
	/**
	 * Returns the authenticated user\'s information.
	 * @summary Retrieve Authenticated User
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UsersApi
	 */
	public findOneUser(options?: RawAxiosRequestConfig) {
		return UsersApiFp(this.configuration)
			.findOneUser(options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Updates the nickname of the authenticated user.
	 * @summary Update User Nickname
	 * @param {ChangeNicknameRequest} changeNicknameRequest
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UsersApi
	 */
	public updateUserNickname(
		changeNicknameRequest: ChangeNicknameRequest,
		options?: RawAxiosRequestConfig
	) {
		return UsersApiFp(this.configuration)
			.updateUserNickname(changeNicknameRequest, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * WorkspaceDocumentsApi - axios parameter creator
 * @export
 */
export const WorkspaceDocumentsApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * Creates a new document with a title in the specified workspace.
		 * @summary Create a Document
		 * @param {string} workspaceId
		 * @param {CreateWorkspaceDocumentRequest} createWorkspaceDocumentRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createWorkspaceDocument: async (
			workspaceId: string,
			createWorkspaceDocumentRequest: CreateWorkspaceDocumentRequest,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'workspaceId' is not null or undefined
			assertParamExists("createWorkspaceDocument", "workspaceId", workspaceId);
			// verify required parameter 'createWorkspaceDocumentRequest' is not null or undefined
			assertParamExists(
				"createWorkspaceDocument",
				"createWorkspaceDocumentRequest",
				createWorkspaceDocumentRequest
			);
			const localVarPath = `/workspaces/{workspace_id}/documents`.replace(
				`{${"workspace_id"}}`,
				encodeURIComponent(String(workspaceId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				createWorkspaceDocumentRequest,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Generates a share token for a document, if the user has the necessary permissions.
		 * @summary Create a Document Share Token
		 * @param {string} workspaceId
		 * @param {string} documentId
		 * @param {CreateWorkspaceDocumentShareTokenRequest} createWorkspaceDocumentShareTokenRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createWorkspaceDocumentShareToken: async (
			workspaceId: string,
			documentId: string,
			createWorkspaceDocumentShareTokenRequest: CreateWorkspaceDocumentShareTokenRequest,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'workspaceId' is not null or undefined
			assertParamExists("createWorkspaceDocumentShareToken", "workspaceId", workspaceId);
			// verify required parameter 'documentId' is not null or undefined
			assertParamExists("createWorkspaceDocumentShareToken", "documentId", documentId);
			// verify required parameter 'createWorkspaceDocumentShareTokenRequest' is not null or undefined
			assertParamExists(
				"createWorkspaceDocumentShareToken",
				"createWorkspaceDocumentShareTokenRequest",
				createWorkspaceDocumentShareTokenRequest
			);
			const localVarPath = `/workspaces/{workspace_id}/documents/{document_id}/share-token`
				.replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
				.replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				createWorkspaceDocumentShareTokenRequest,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Returns a paginated list of documents in the specified workspace. Supports KeySet pagination.
		 * @summary List Documents in a Workspace
		 * @param {string} workspaceId
		 * @param {number} [pageSize] Page size to fetch (defaults to 10)
		 * @param {string} [cursor] Returns next set of results after this cursor. If none provided, returns the first page.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		findManyWorkspaceDocuments: async (
			workspaceId: string,
			pageSize?: number,
			cursor?: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'workspaceId' is not null or undefined
			assertParamExists("findManyWorkspaceDocuments", "workspaceId", workspaceId);
			const localVarPath = `/workspaces/{workspace_id}/documents`.replace(
				`{${"workspace_id"}}`,
				encodeURIComponent(String(workspaceId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			if (pageSize !== undefined) {
				localVarQueryParameter["page_size"] = pageSize;
			}

			if (cursor !== undefined) {
				localVarQueryParameter["cursor"] = cursor;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Returns a single document from the workspace if the user has access.
		 * @summary Retrieve a Document in a Workspace
		 * @param {string} workspaceId
		 * @param {string} documentId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		findOneWorkspaceDocument: async (
			workspaceId: string,
			documentId: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'workspaceId' is not null or undefined
			assertParamExists("findOneWorkspaceDocument", "workspaceId", workspaceId);
			// verify required parameter 'documentId' is not null or undefined
			assertParamExists("findOneWorkspaceDocument", "documentId", documentId);
			const localVarPath = `/workspaces/{workspace_id}/documents/{document_id}`
				.replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
				.replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Updates the title of a specific document, if the user has access permissions.
		 * @summary Update a Document Title
		 * @param {string} workspaceId ID of the workspace
		 * @param {string} documentId ID of the document to rename
		 * @param {UpdateDocumentTitleRequest} updateDocumentTitleRequest The new title of the document
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateWorkspaceDocumentTitle: async (
			workspaceId: string,
			documentId: string,
			updateDocumentTitleRequest: UpdateDocumentTitleRequest,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'workspaceId' is not null or undefined
			assertParamExists("updateWorkspaceDocumentTitle", "workspaceId", workspaceId);
			// verify required parameter 'documentId' is not null or undefined
			assertParamExists("updateWorkspaceDocumentTitle", "documentId", documentId);
			// verify required parameter 'updateDocumentTitleRequest' is not null or undefined
			assertParamExists(
				"updateWorkspaceDocumentTitle",
				"updateDocumentTitleRequest",
				updateDocumentTitleRequest
			);
			const localVarPath = `/workspaces/{workspace_id}/documents/{document_id}`
				.replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
				.replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				updateDocumentTitleRequest,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * WorkspaceDocumentsApi - functional programming interface
 * @export
 */
export const WorkspaceDocumentsApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = WorkspaceDocumentsApiAxiosParamCreator(configuration);
	return {
		/**
		 * Creates a new document with a title in the specified workspace.
		 * @summary Create a Document
		 * @param {string} workspaceId
		 * @param {CreateWorkspaceDocumentRequest} createWorkspaceDocumentRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async createWorkspaceDocument(
			workspaceId: string,
			createWorkspaceDocumentRequest: CreateWorkspaceDocumentRequest,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceDocumentDomain>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkspaceDocument(
				workspaceId,
				createWorkspaceDocumentRequest,
				options
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["WorkspaceDocumentsApi.createWorkspaceDocument"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * Generates a share token for a document, if the user has the necessary permissions.
		 * @summary Create a Document Share Token
		 * @param {string} workspaceId
		 * @param {string} documentId
		 * @param {CreateWorkspaceDocumentShareTokenRequest} createWorkspaceDocumentShareTokenRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async createWorkspaceDocumentShareToken(
			workspaceId: string,
			documentId: string,
			createWorkspaceDocumentShareTokenRequest: CreateWorkspaceDocumentShareTokenRequest,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<CreateWorkspaceDocumentShareTokenResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.createWorkspaceDocumentShareToken(
					workspaceId,
					documentId,
					createWorkspaceDocumentShareTokenRequest,
					options
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["WorkspaceDocumentsApi.createWorkspaceDocumentShareToken"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * Returns a paginated list of documents in the specified workspace. Supports KeySet pagination.
		 * @summary List Documents in a Workspace
		 * @param {string} workspaceId
		 * @param {number} [pageSize] Page size to fetch (defaults to 10)
		 * @param {string} [cursor] Returns next set of results after this cursor. If none provided, returns the first page.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async findManyWorkspaceDocuments(
			workspaceId: string,
			pageSize?: number,
			cursor?: string,
			options?: RawAxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.findManyWorkspaceDocuments(
				workspaceId,
				pageSize,
				cursor,
				options
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["WorkspaceDocumentsApi.findManyWorkspaceDocuments"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * Returns a single document from the workspace if the user has access.
		 * @summary Retrieve a Document in a Workspace
		 * @param {string} workspaceId
		 * @param {string} documentId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async findOneWorkspaceDocument(
			workspaceId: string,
			documentId: string,
			options?: RawAxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.findOneWorkspaceDocument(
				workspaceId,
				documentId,
				options
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["WorkspaceDocumentsApi.findOneWorkspaceDocument"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * Updates the title of a specific document, if the user has access permissions.
		 * @summary Update a Document Title
		 * @param {string} workspaceId ID of the workspace
		 * @param {string} documentId ID of the document to rename
		 * @param {UpdateDocumentTitleRequest} updateDocumentTitleRequest The new title of the document
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async updateWorkspaceDocumentTitle(
			workspaceId: string,
			documentId: string,
			updateDocumentTitleRequest: UpdateDocumentTitleRequest,
			options?: RawAxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkspaceDocumentTitle(
				workspaceId,
				documentId,
				updateDocumentTitleRequest,
				options
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["WorkspaceDocumentsApi.updateWorkspaceDocumentTitle"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
	};
};

/**
 * WorkspaceDocumentsApi - factory interface
 * @export
 */
export const WorkspaceDocumentsApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = WorkspaceDocumentsApiFp(configuration);
	return {
		/**
		 * Creates a new document with a title in the specified workspace.
		 * @summary Create a Document
		 * @param {string} workspaceId
		 * @param {CreateWorkspaceDocumentRequest} createWorkspaceDocumentRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createWorkspaceDocument(
			workspaceId: string,
			createWorkspaceDocumentRequest: CreateWorkspaceDocumentRequest,
			options?: RawAxiosRequestConfig
		): AxiosPromise<WorkspaceDocumentDomain> {
			return localVarFp
				.createWorkspaceDocument(workspaceId, createWorkspaceDocumentRequest, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Generates a share token for a document, if the user has the necessary permissions.
		 * @summary Create a Document Share Token
		 * @param {string} workspaceId
		 * @param {string} documentId
		 * @param {CreateWorkspaceDocumentShareTokenRequest} createWorkspaceDocumentShareTokenRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createWorkspaceDocumentShareToken(
			workspaceId: string,
			documentId: string,
			createWorkspaceDocumentShareTokenRequest: CreateWorkspaceDocumentShareTokenRequest,
			options?: RawAxiosRequestConfig
		): AxiosPromise<CreateWorkspaceDocumentShareTokenResponse> {
			return localVarFp
				.createWorkspaceDocumentShareToken(
					workspaceId,
					documentId,
					createWorkspaceDocumentShareTokenRequest,
					options
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Returns a paginated list of documents in the specified workspace. Supports KeySet pagination.
		 * @summary List Documents in a Workspace
		 * @param {string} workspaceId
		 * @param {number} [pageSize] Page size to fetch (defaults to 10)
		 * @param {string} [cursor] Returns next set of results after this cursor. If none provided, returns the first page.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		findManyWorkspaceDocuments(
			workspaceId: string,
			pageSize?: number,
			cursor?: string,
			options?: RawAxiosRequestConfig
		): AxiosPromise<void> {
			return localVarFp
				.findManyWorkspaceDocuments(workspaceId, pageSize, cursor, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Returns a single document from the workspace if the user has access.
		 * @summary Retrieve a Document in a Workspace
		 * @param {string} workspaceId
		 * @param {string} documentId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		findOneWorkspaceDocument(
			workspaceId: string,
			documentId: string,
			options?: RawAxiosRequestConfig
		): AxiosPromise<void> {
			return localVarFp
				.findOneWorkspaceDocument(workspaceId, documentId, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Updates the title of a specific document, if the user has access permissions.
		 * @summary Update a Document Title
		 * @param {string} workspaceId ID of the workspace
		 * @param {string} documentId ID of the document to rename
		 * @param {UpdateDocumentTitleRequest} updateDocumentTitleRequest The new title of the document
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateWorkspaceDocumentTitle(
			workspaceId: string,
			documentId: string,
			updateDocumentTitleRequest: UpdateDocumentTitleRequest,
			options?: RawAxiosRequestConfig
		): AxiosPromise<void> {
			return localVarFp
				.updateWorkspaceDocumentTitle(
					workspaceId,
					documentId,
					updateDocumentTitleRequest,
					options
				)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * WorkspaceDocumentsApi - object-oriented interface
 * @export
 * @class WorkspaceDocumentsApi
 * @extends {BaseAPI}
 */
export class WorkspaceDocumentsApi extends BaseAPI {
	/**
	 * Creates a new document with a title in the specified workspace.
	 * @summary Create a Document
	 * @param {string} workspaceId
	 * @param {CreateWorkspaceDocumentRequest} createWorkspaceDocumentRequest
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof WorkspaceDocumentsApi
	 */
	public createWorkspaceDocument(
		workspaceId: string,
		createWorkspaceDocumentRequest: CreateWorkspaceDocumentRequest,
		options?: RawAxiosRequestConfig
	) {
		return WorkspaceDocumentsApiFp(this.configuration)
			.createWorkspaceDocument(workspaceId, createWorkspaceDocumentRequest, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Generates a share token for a document, if the user has the necessary permissions.
	 * @summary Create a Document Share Token
	 * @param {string} workspaceId
	 * @param {string} documentId
	 * @param {CreateWorkspaceDocumentShareTokenRequest} createWorkspaceDocumentShareTokenRequest
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof WorkspaceDocumentsApi
	 */
	public createWorkspaceDocumentShareToken(
		workspaceId: string,
		documentId: string,
		createWorkspaceDocumentShareTokenRequest: CreateWorkspaceDocumentShareTokenRequest,
		options?: RawAxiosRequestConfig
	) {
		return WorkspaceDocumentsApiFp(this.configuration)
			.createWorkspaceDocumentShareToken(
				workspaceId,
				documentId,
				createWorkspaceDocumentShareTokenRequest,
				options
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Returns a paginated list of documents in the specified workspace. Supports KeySet pagination.
	 * @summary List Documents in a Workspace
	 * @param {string} workspaceId
	 * @param {number} [pageSize] Page size to fetch (defaults to 10)
	 * @param {string} [cursor] Returns next set of results after this cursor. If none provided, returns the first page.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof WorkspaceDocumentsApi
	 */
	public findManyWorkspaceDocuments(
		workspaceId: string,
		pageSize?: number,
		cursor?: string,
		options?: RawAxiosRequestConfig
	) {
		return WorkspaceDocumentsApiFp(this.configuration)
			.findManyWorkspaceDocuments(workspaceId, pageSize, cursor, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Returns a single document from the workspace if the user has access.
	 * @summary Retrieve a Document in a Workspace
	 * @param {string} workspaceId
	 * @param {string} documentId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof WorkspaceDocumentsApi
	 */
	public findOneWorkspaceDocument(
		workspaceId: string,
		documentId: string,
		options?: RawAxiosRequestConfig
	) {
		return WorkspaceDocumentsApiFp(this.configuration)
			.findOneWorkspaceDocument(workspaceId, documentId, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Updates the title of a specific document, if the user has access permissions.
	 * @summary Update a Document Title
	 * @param {string} workspaceId ID of the workspace
	 * @param {string} documentId ID of the document to rename
	 * @param {UpdateDocumentTitleRequest} updateDocumentTitleRequest The new title of the document
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof WorkspaceDocumentsApi
	 */
	public updateWorkspaceDocumentTitle(
		workspaceId: string,
		documentId: string,
		updateDocumentTitleRequest: UpdateDocumentTitleRequest,
		options?: RawAxiosRequestConfig
	) {
		return WorkspaceDocumentsApiFp(this.configuration)
			.updateWorkspaceDocumentTitle(
				workspaceId,
				documentId,
				updateDocumentTitleRequest,
				options
			)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * WorkspaceUsersApi - axios parameter creator
 * @export
 */
export const WorkspaceUsersApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * Returns a list of users in the specified workspace. Supports KeySet pagination.
		 * @summary List Users in a Workspace
		 * @param {string} workspaceId
		 * @param {number} [pageSize] Page size to fetch (defaults to 10)
		 * @param {string} [cursor] Returns next set of results after this cursor. If none provided, returns the first page.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		findManyWorkspaceUsers: async (
			workspaceId: string,
			pageSize?: number,
			cursor?: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'workspaceId' is not null or undefined
			assertParamExists("findManyWorkspaceUsers", "workspaceId", workspaceId);
			const localVarPath = `/workspaces/{workspace_id}/users`.replace(
				`{${"workspace_id"}}`,
				encodeURIComponent(String(workspaceId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			if (pageSize !== undefined) {
				localVarQueryParameter["page_size"] = pageSize;
			}

			if (cursor !== undefined) {
				localVarQueryParameter["cursor"] = cursor;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * WorkspaceUsersApi - functional programming interface
 * @export
 */
export const WorkspaceUsersApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = WorkspaceUsersApiAxiosParamCreator(configuration);
	return {
		/**
		 * Returns a list of users in the specified workspace. Supports KeySet pagination.
		 * @summary List Users in a Workspace
		 * @param {string} workspaceId
		 * @param {number} [pageSize] Page size to fetch (defaults to 10)
		 * @param {string} [cursor] Returns next set of results after this cursor. If none provided, returns the first page.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async findManyWorkspaceUsers(
			workspaceId: string,
			pageSize?: number,
			cursor?: string,
			options?: RawAxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.findManyWorkspaceUsers(
				workspaceId,
				pageSize,
				cursor,
				options
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["WorkspaceUsersApi.findManyWorkspaceUsers"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
	};
};

/**
 * WorkspaceUsersApi - factory interface
 * @export
 */
export const WorkspaceUsersApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = WorkspaceUsersApiFp(configuration);
	return {
		/**
		 * Returns a list of users in the specified workspace. Supports KeySet pagination.
		 * @summary List Users in a Workspace
		 * @param {string} workspaceId
		 * @param {number} [pageSize] Page size to fetch (defaults to 10)
		 * @param {string} [cursor] Returns next set of results after this cursor. If none provided, returns the first page.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		findManyWorkspaceUsers(
			workspaceId: string,
			pageSize?: number,
			cursor?: string,
			options?: RawAxiosRequestConfig
		): AxiosPromise<void> {
			return localVarFp
				.findManyWorkspaceUsers(workspaceId, pageSize, cursor, options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * WorkspaceUsersApi - object-oriented interface
 * @export
 * @class WorkspaceUsersApi
 * @extends {BaseAPI}
 */
export class WorkspaceUsersApi extends BaseAPI {
	/**
	 * Returns a list of users in the specified workspace. Supports KeySet pagination.
	 * @summary List Users in a Workspace
	 * @param {string} workspaceId
	 * @param {number} [pageSize] Page size to fetch (defaults to 10)
	 * @param {string} [cursor] Returns next set of results after this cursor. If none provided, returns the first page.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof WorkspaceUsersApi
	 */
	public findManyWorkspaceUsers(
		workspaceId: string,
		pageSize?: number,
		cursor?: string,
		options?: RawAxiosRequestConfig
	) {
		return WorkspaceUsersApiFp(this.configuration)
			.findManyWorkspaceUsers(workspaceId, pageSize, cursor, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * WorkspacesApi - axios parameter creator
 * @export
 */
export const WorkspacesApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * Creates a new workspace with the given title.
		 * @summary Create a Workspace
		 * @param {CreateWorkspaceRequest} createWorkspaceRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createWorkspace: async (
			createWorkspaceRequest: CreateWorkspaceRequest,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'createWorkspaceRequest' is not null or undefined
			assertParamExists("createWorkspace", "createWorkspaceRequest", createWorkspaceRequest);
			const localVarPath = `/workspaces`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				createWorkspaceRequest,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Generates an invitation token (JWT) for inviting users to the specified workspace.
		 * @summary Create an Invitation Token
		 * @param {string} workspaceId ID of the workspace to which the token grants access
		 * @param {CreateInvitationTokenRequest} createInvitationTokenRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createWorkspaceInvitationToken: async (
			workspaceId: string,
			createInvitationTokenRequest: CreateInvitationTokenRequest,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'workspaceId' is not null or undefined
			assertParamExists("createWorkspaceInvitationToken", "workspaceId", workspaceId);
			// verify required parameter 'createInvitationTokenRequest' is not null or undefined
			assertParamExists(
				"createWorkspaceInvitationToken",
				"createInvitationTokenRequest",
				createInvitationTokenRequest
			);
			const localVarPath = `/workspaces/{workspace_id}/invite-token`.replace(
				`{${"workspace_id"}}`,
				encodeURIComponent(String(workspaceId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				createInvitationTokenRequest,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Returns the authenticated user\'s workspaces. Supports KeySet pagination.
		 * @summary Retrieve Workspaces List
		 * @param {number} [pageSize] Page size to fetch (defaults to 10)
		 * @param {string} [cursor] Returns next set of results after this cursor. If none provided, returns the first page.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		findManyWorkspaces: async (
			pageSize?: number,
			cursor?: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/workspaces`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			if (pageSize !== undefined) {
				localVarQueryParameter["page_size"] = pageSize;
			}

			if (cursor !== undefined) {
				localVarQueryParameter["cursor"] = cursor;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Returns the workspace if the user has the required access permissions.
		 * @summary Retrieve a Specific Workspace
		 * @param {string} workspaceSlug
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		findOneWorkspace: async (
			workspaceSlug: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'workspaceSlug' is not null or undefined
			assertParamExists("findOneWorkspace", "workspaceSlug", workspaceSlug);
			const localVarPath = `/workspaces/{workspace_slug}`.replace(
				`{${"workspace_slug"}}`,
				encodeURIComponent(String(workspaceSlug))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Joins a workspace using a valid JWT invitation token.
		 * @summary Join a Workspace
		 * @param {JoinWorkspaceRequest} joinWorkspaceRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		joinWorkspace: async (
			joinWorkspaceRequest: JoinWorkspaceRequest,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'joinWorkspaceRequest' is not null or undefined
			assertParamExists("joinWorkspace", "joinWorkspaceRequest", joinWorkspaceRequest);
			const localVarPath = `/workspaces/join`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				joinWorkspaceRequest,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * WorkspacesApi - functional programming interface
 * @export
 */
export const WorkspacesApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = WorkspacesApiAxiosParamCreator(configuration);
	return {
		/**
		 * Creates a new workspace with the given title.
		 * @summary Create a Workspace
		 * @param {CreateWorkspaceRequest} createWorkspaceRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async createWorkspace(
			createWorkspaceRequest: CreateWorkspaceRequest,
			options?: RawAxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceDomain>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkspace(
				createWorkspaceRequest,
				options
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["WorkspacesApi.createWorkspace"]?.[localVarOperationServerIndex]
					?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * Generates an invitation token (JWT) for inviting users to the specified workspace.
		 * @summary Create an Invitation Token
		 * @param {string} workspaceId ID of the workspace to which the token grants access
		 * @param {CreateInvitationTokenRequest} createInvitationTokenRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async createWorkspaceInvitationToken(
			workspaceId: string,
			createInvitationTokenRequest: CreateInvitationTokenRequest,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<CreateInvitationTokenResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.createWorkspaceInvitationToken(
					workspaceId,
					createInvitationTokenRequest,
					options
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["WorkspacesApi.createWorkspaceInvitationToken"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * Returns the authenticated user\'s workspaces. Supports KeySet pagination.
		 * @summary Retrieve Workspaces List
		 * @param {number} [pageSize] Page size to fetch (defaults to 10)
		 * @param {string} [cursor] Returns next set of results after this cursor. If none provided, returns the first page.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async findManyWorkspaces(
			pageSize?: number,
			cursor?: string,
			options?: RawAxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.findManyWorkspaces(
				pageSize,
				cursor,
				options
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["WorkspacesApi.findManyWorkspaces"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * Returns the workspace if the user has the required access permissions.
		 * @summary Retrieve a Specific Workspace
		 * @param {string} workspaceSlug
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async findOneWorkspace(
			workspaceSlug: string,
			options?: RawAxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.findOneWorkspace(
				workspaceSlug,
				options
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["WorkspacesApi.findOneWorkspace"]?.[localVarOperationServerIndex]
					?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * Joins a workspace using a valid JWT invitation token.
		 * @summary Join a Workspace
		 * @param {JoinWorkspaceRequest} joinWorkspaceRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async joinWorkspace(
			joinWorkspaceRequest: JoinWorkspaceRequest,
			options?: RawAxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceDomain>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.joinWorkspace(
				joinWorkspaceRequest,
				options
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["WorkspacesApi.joinWorkspace"]?.[localVarOperationServerIndex]
					?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
	};
};

/**
 * WorkspacesApi - factory interface
 * @export
 */
export const WorkspacesApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = WorkspacesApiFp(configuration);
	return {
		/**
		 * Creates a new workspace with the given title.
		 * @summary Create a Workspace
		 * @param {CreateWorkspaceRequest} createWorkspaceRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createWorkspace(
			createWorkspaceRequest: CreateWorkspaceRequest,
			options?: RawAxiosRequestConfig
		): AxiosPromise<WorkspaceDomain> {
			return localVarFp
				.createWorkspace(createWorkspaceRequest, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Generates an invitation token (JWT) for inviting users to the specified workspace.
		 * @summary Create an Invitation Token
		 * @param {string} workspaceId ID of the workspace to which the token grants access
		 * @param {CreateInvitationTokenRequest} createInvitationTokenRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createWorkspaceInvitationToken(
			workspaceId: string,
			createInvitationTokenRequest: CreateInvitationTokenRequest,
			options?: RawAxiosRequestConfig
		): AxiosPromise<CreateInvitationTokenResponse> {
			return localVarFp
				.createWorkspaceInvitationToken(workspaceId, createInvitationTokenRequest, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Returns the authenticated user\'s workspaces. Supports KeySet pagination.
		 * @summary Retrieve Workspaces List
		 * @param {number} [pageSize] Page size to fetch (defaults to 10)
		 * @param {string} [cursor] Returns next set of results after this cursor. If none provided, returns the first page.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		findManyWorkspaces(
			pageSize?: number,
			cursor?: string,
			options?: RawAxiosRequestConfig
		): AxiosPromise<void> {
			return localVarFp
				.findManyWorkspaces(pageSize, cursor, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Returns the workspace if the user has the required access permissions.
		 * @summary Retrieve a Specific Workspace
		 * @param {string} workspaceSlug
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		findOneWorkspace(
			workspaceSlug: string,
			options?: RawAxiosRequestConfig
		): AxiosPromise<void> {
			return localVarFp
				.findOneWorkspace(workspaceSlug, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Joins a workspace using a valid JWT invitation token.
		 * @summary Join a Workspace
		 * @param {JoinWorkspaceRequest} joinWorkspaceRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		joinWorkspace(
			joinWorkspaceRequest: JoinWorkspaceRequest,
			options?: RawAxiosRequestConfig
		): AxiosPromise<WorkspaceDomain> {
			return localVarFp
				.joinWorkspace(joinWorkspaceRequest, options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * WorkspacesApi - object-oriented interface
 * @export
 * @class WorkspacesApi
 * @extends {BaseAPI}
 */
export class WorkspacesApi extends BaseAPI {
	/**
	 * Creates a new workspace with the given title.
	 * @summary Create a Workspace
	 * @param {CreateWorkspaceRequest} createWorkspaceRequest
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof WorkspacesApi
	 */
	public createWorkspace(
		createWorkspaceRequest: CreateWorkspaceRequest,
		options?: RawAxiosRequestConfig
	) {
		return WorkspacesApiFp(this.configuration)
			.createWorkspace(createWorkspaceRequest, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Generates an invitation token (JWT) for inviting users to the specified workspace.
	 * @summary Create an Invitation Token
	 * @param {string} workspaceId ID of the workspace to which the token grants access
	 * @param {CreateInvitationTokenRequest} createInvitationTokenRequest
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof WorkspacesApi
	 */
	public createWorkspaceInvitationToken(
		workspaceId: string,
		createInvitationTokenRequest: CreateInvitationTokenRequest,
		options?: RawAxiosRequestConfig
	) {
		return WorkspacesApiFp(this.configuration)
			.createWorkspaceInvitationToken(workspaceId, createInvitationTokenRequest, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Returns the authenticated user\'s workspaces. Supports KeySet pagination.
	 * @summary Retrieve Workspaces List
	 * @param {number} [pageSize] Page size to fetch (defaults to 10)
	 * @param {string} [cursor] Returns next set of results after this cursor. If none provided, returns the first page.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof WorkspacesApi
	 */
	public findManyWorkspaces(pageSize?: number, cursor?: string, options?: RawAxiosRequestConfig) {
		return WorkspacesApiFp(this.configuration)
			.findManyWorkspaces(pageSize, cursor, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Returns the workspace if the user has the required access permissions.
	 * @summary Retrieve a Specific Workspace
	 * @param {string} workspaceSlug
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof WorkspacesApi
	 */
	public findOneWorkspace(workspaceSlug: string, options?: RawAxiosRequestConfig) {
		return WorkspacesApiFp(this.configuration)
			.findOneWorkspace(workspaceSlug, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Joins a workspace using a valid JWT invitation token.
	 * @summary Join a Workspace
	 * @param {JoinWorkspaceRequest} joinWorkspaceRequest
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof WorkspacesApi
	 */
	public joinWorkspace(
		joinWorkspaceRequest: JoinWorkspaceRequest,
		options?: RawAxiosRequestConfig
	) {
		return WorkspacesApiFp(this.configuration)
			.joinWorkspace(joinWorkspaceRequest, options)
			.then((request) => request(this.axios, this.basePath));
	}
}
